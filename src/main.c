//=========================================================
// src/bringup_test_main.c: generated by Hardware Configurator
//
// This file will be updated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!!
//=========================================================

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include <display.h>
#include <SI_EFM8BB3_Register_Enums.h>                  // SFR declarations
#include "InitDevice.h"
//#include "ST7735S-2.0/st7735s.h"
//#include "st7735s.h"
//#include "fonts.h"
//#include "gfx.h"
#include "main.h"

#include <SI_EFM8BB3_Register_Enums.h> // SFR declarations
#include "InitDevice.h"
#include "si_toolchain.h"

#include "synth_interface/synth_common.h"
#include "utility.h"
#include "led_controls.h"
#include "touch_keys.h"

#include "button_functions/page0.h"
#include "button_functions/page1.h"
#include "button_functions/page2.h"
#include "button_functions/page3.h"

#include "persistance.h"
#include "touch_keys.h"

#include "adc_0.h"

#include "interrupts.h"

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include "loader.h"
#include "uzlib.h"

#define MAX_LCD_REFRESH 1000/20



BUTTON_FUNC code BUTTON_1_FUNC[4] =
  { &b0F0, &b0F1, &b0F2, &b0F3 };
BUTTON_FUNC code BUTTON_2_FUNC[4] =
  { &b1F0, &b1F1, &b1F2, &b1F3 };
BUTTON_FUNC code BUTTON_3_FUNC[4] =
  { &b2F0, &b2F1, &b2F2, &b2F3 };

BUTTON_FUNC *code B_FUNC_PAGES[3] =
  { BUTTON_1_FUNC, BUTTON_2_FUNC, BUTTON_3_FUNC };

volatile uint8_t last_result[4];
volatile uint32_t touch_timer[4];
volatile uint8_t hold_ctr[4];

volatile uint32_t lcd_refresh_timer;

extern volatile bool adc_scan_active;
volatile bool page_changed = true;

void
beginADCScan ()
{
  adc_scan_active = true;
  ADC0_startConversion ();
}

void setSynthEN (volatile bool en){P1_B5 = en;}
void setCoreEN (volatile bool en){P1_B6 = en;}

uint8_t
button4Functions ()
{
  uint8_t i = 3;

  //short: change page, long: reset

  if (hold_ctr[i] > RESET_HOLD_COUNT){


      softPowerCycle();
      touch_timer[i] = millis ();
      hold_ctr[i] = 0;
      resetLEDi(i,0,LED_LOW);
            //return 1;
  }

  else if (hold_ctr[i] > 8)
    {
      hold_ctr[i]++;
      touch_timer[i] = millis ();
      PCA0CPH0 = 0xF2;
      PCA0CPM0 |= (1 << 1);
      return 1;
    }
  else if (hold_ctr[i] > 3)
    {
      hold_ctr[i]++;
      touch_timer[i] = millis ();
      PCA0CPH0 = 0xFF;
      PCA0CPM0 |= (1 << 1);
      return 1;
    }
  else if (hold_ctr[i] > 0)
    {
      hold_ctr[i]++;
      touch_timer[i] = millis ();
      return 1;
    }
  else
    {
      //short press

      hold_ctr[i]++;
      touch_timer[i] = millis ();
      PCA0CPH0 = 0xF2;
      PCA0CPM0 |= (1 << 1);
      return 1;
    }

  return 0;
}

/**
 * button 4 (top) short press
 */
void button4ShortPress ()
{
  page_changed = true;

  //switch page
  active_config.function_page++;
  if (active_config.function_page > 3)
    active_config.function_page = 0;

  //show page indicator animation
  funcPageLEDAni (active_config.function_page);
}

// $[Generated Includes]
// [Generated Includes]$

//-----------------------------------------------------------------------------
// SiLabs_Startup() Routine
// ----------------------------------------------------------------------------
// This function is called immediately after reset, before the initialization
// code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
// useful place to disable the watchdog timer, which is enable by default
// and may trigger before main() in some instances.
//-----------------------------------------------------------------------------
void SiLabs_Startup (void)
{
  // $[SiLabs Startup]
  // [SiLabs Startup]$
}



//-----------------------------------------------------------------------------
// main() Routine
// ----------------------------------------------------------------------------

extern ADC0_AutoscanBuffer_t BUFFER1;
extern ADC0_AutoscanBuffer_t *CURRENT_BUFFER;
extern bool CONVERSION_COMPLETE;
extern volatile bool ready_new;

void Autoscan_init (void)
{
  uint8_t i = 0;

  ADC0_enable ();
  ADC0_enableInt (ADC0_CONVERSION_COMPLETE_IF, true);
  ADC0_setAutoscanInputs (ADC0_POSITIVE_INPUT_P17, 4);
  CURRENT_BUFFER = &BUFFER1;
  ADC0_enableAutoscan (CURRENT_BUFFER, BUFFER_SIZE,
                       ADC0_AUTOSCAN_MODE_CONTINUOUS);
  ADC0_setNextAutoscanBuffer (&BUFFER1, BUFFER_SIZE);

  ADC0CN2 |= ADC0CN2_ADCM__TIMER4;

  beginADCScan ();
  while (adc_scan_active);
}

//uint8_t spi_bytes[] = {};
volatile int zk;
volatile uint16_t i;
volatile uint8_t args;
//volatile char code hi_str[] =
//    "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.";
volatile char l1buf[20];
volatile char l2buf[10];
//volatile char l3buf[10];
//volatile char l4buf[10];
volatile uint32_t timer;
volatile uint8_t pmdbak = 0;
volatile uint32_t timer2;

volatile char *char_ptr;

volatile uint32_t conversion_timer;
volatile bool has_sampled = false;

void setForceRST(bool en){P3_B3 = en;}
void setAmpEN (bool en){P3_B1 = en;}
void setDisplayBL(bool en){P1_B2 = en;}
void setDisplayRST(bool en){P3_B4 = !en;}

void powerOnInit(){

  setForceRST(DISABLED);
  setDisplayBL(POWER_OFF);
  setDisplayRST(POWER_OFF);
  setCoreEN(POWER_OFF);
  setSynthEN(POWER_OFF);
  setAmpEN(POWER_OFF);

  delayMS(100);

  if (!read_cfg ())
  {
    //active_config = {0};


      calibrateTouch ();
    write_cfg ();
  }

  setCoreEN(POWER_ON);
  setSynthEN(POWER_ON);

  //wait for synth to come up
  delayMS(2000);

  init_synth_mode ();
  lcdInit();
  Autoscan_init ();

  forceLCDRefresh();
  refresh_lcd();

  funcPageLEDAni (active_config.function_page); //page indicator

  setDisplayBL(POWER_ON);

  delayMS(10);
  setAmpEN(POWER_ON);

  power_state = POWER_ON;
}

void softPowerCycle(){

  float calc2;


  if(power_state)
  {
      setForceRST(DISABLED);
      setDisplayBL(POWER_OFF);
      setDisplayRST(POWER_OFF);
      setCoreEN(POWER_OFF);
      setSynthEN(POWER_OFF);
      setAmpEN(POWER_OFF);

      delayMS(100);

      power_state = POWER_OFF;

      //check to see if the board is being powered from the CHMOD USB
      req_adc_vals = true;
      while (req_adc_vals);

      calc2 = adc_buffer[0];
      calc2 /= 4096.0;
      calc2 *= 3.3;
      calc2 *= 2.0;
      if ((int)calc2 >= 3)
      {

        bool rst_flag = false;
        char attempt_ctr = 0;

        while(!rst_flag && attempt_ctr < 10)
          {

            uint32_t localtmr = millis();

            //this may result in a hard reset.
            req_adc_vals = true;
            setForceRST(ENABLED);

            do
              {

            //req_adc_vals = true;
                  while (req_adc_vals);
                  calc2 = adc_buffer[0];
                  req_adc_vals = true;
                        calc2 /= 4096.0;
                        calc2 *= 3.3;
                        calc2 *= 2.0;

                        if((int)calc2 < 3)
                          rst_flag = true;


              }while(!rst_flag && ((uint32_t)((int32_t)millis()-localtmr) < 100));



            setForceRST(DISABLED);

            delayMS(1000);

            attempt_ctr++;
          }

        req_adc_vals = true;
          while (req_adc_vals);
          calc2 = adc_buffer[0];
          calc2 /= 4096.0;
          calc2 *= 3.3;
          calc2 *= 2.0;
          if ((int)calc2 >= 3)
            {
              //the synth was only reset so turn the rest of the stuff back on
              softPowerCycle();
            }
      }


  }
  else
    {
      //the system is in soft power off state. turn it back on.

      setForceRST(DISABLED);
      setCoreEN(POWER_ON);
      setSynthEN(POWER_ON);

      //wait for synth to come up
      delayMS(2000);

      init_synth_mode ();

      lcdInit();
      delayMS(100);

      setDisplayBL(POWER_ON);

      delayMS(100);
      setAmpEN(POWER_ON);

      power_state = POWER_ON;
    }
}

void forceLCDRefresh ()
{
  title_changed = true;
  page_changed = true;
}

extern volatile char prog_name[];

void refresh_lcd ()
{

  uint8_t num_chars;

  if ((uint32_t) ((int32_t) millis () - lcd_refresh_timer) < MAX_LCD_REFRESH)
    return;

  lcd_refresh_timer = millis ();

  memset (l1buf, ' ', sizeof(l1buf));

  timer2 = millis ();

  if (title_changed)
    {

      fillScreen (ST7735_BLACK);
      prog_name[23] = '\0';
      drawtextq (1, 1, prog_name, ST7735_WHITE, ST7735_BLACK, 2);
      title_changed = false;

      l1buf[0] = active_config.function_page;
      l1buf[0] += 0x31;
      l1buf[1] = '\0';
      drawtextq (142, 54, l1buf, ST7735_WHITE, ST7735_BLACK, 2);
      drawtextq (135, 72, "MENU", ST7735_WHITE, ST7735_BLACK, 1);

      memset (l1buf, ' ', sizeof(l1buf));
      memcpy (l1buf, (active_config.system_mode == XFM_MODE ? "XFM" : "XVA"),
              3);
      l1buf[3] = '-';
      l1buf[4] = '\0';
      drawtextq (1, 65, l1buf, ST7735_WHITE, ST7735_BLACK, 2);

      num_chars = sprintf (l1buf, "%u", (int) active_config.active_preset.base);
      drawtextq (
          49,
          65,
          l1buf,
          (active_config.unit_number || active_config.system_mode != XFM_MODE) ?
              ST7735_WHITE : ST7735_RED,
          ST7735_BLACK, 2);

      if (active_config.system_mode == XFM_MODE)
        for (i = 0;; i++)
          {
            if (l1buf[i] == '\0')
              {
                l1buf[0] = ':';
                l1buf[1] = '\0';
                drawtextq (53 + (num_chars * 10), 65, l1buf, ST7735_WHITE,
                           ST7735_BLACK, 2);

                sprintf (l1buf, "%u",
                         (int) active_config.active_preset.extended);
                drawtextq (
                    53 + ((num_chars + 1) * 10), 65, l1buf,
                    active_config.unit_number ? ST7735_RED : ST7735_WHITE,
                    ST7735_BLACK, 2);
                break;
              }
          }
      //drawtextq(1, 65, l1buf, ST7735_WHITE, ST7735_BLACK, 2);
    }

  if (page_changed)
    {
      l1buf[0] = active_config.function_page;
      l1buf[0] += 0x31;
      l1buf[1] = '\0';
      drawtextq (142, 54, l1buf, ST7735_WHITE, ST7735_BLACK, 2);
      drawtextq (135, 72, "MENU", ST7735_WHITE, ST7735_BLACK, 1);
    }

  ready_new = true;
  //ADC0_startConversion();
}

main (void)
{
  uint16_t k = 0;

  uint8_t result[4] = { 0, 0, 0, 0 };

  SYS_CONFIG cfg = { 0 };
  active_config = cfg;

  i = 0;

  // Call hardware initialization routine
  enter_DefaultMode_from_RESET ();



  powerOnInit();

  //init_mempool();
  //decompress_test();
  //tuning_test();

  timer = 0;
  conversion_timer = millis ();
  lcd_refresh_timer = 0;

  while(true)
    {

      resetWDT ();

      sampleTouchSensors ();

      for (i = 0; i < 4; i++)
        result[i] = (b_touch_timer[i] > active_config.persistant_cfg.touch_cal[i]); //1 touched, 0 no touch

      for (i = 0; i < 4; i++)
        {
          if (((result[i] == last_result[i]) && hold_ctr[i] == 0)
              || (uint32_t) ((int32_t) millis () - touch_timer[i]) < 250)
            continue;
          else
            {
              touch_timer[i] = millis ();

              if (result[i]) //button is touched
                {
                  if (i < BUTTON_4)
                    B_FUNC_PAGES[i][active_config.function_page] (0);
                  else
                    button4Functions ();

                  //last_result[i] = result[i];

                  continue;
                }

              if (i == BUTTON_4 && hold_ctr[BUTTON_4] < 3)
                button4ShortPress ();

              if (i < BUTTON_4 && hold_ctr[i] < SHORT_PRESS_MAX_HOLD_COUNT)
                B_FUNC_PAGES[i][active_config.function_page] (SHORT_PRESS);

              hold_ctr[i] = 0;
              last_result[i] = result[i];
            }

          resetLED ();
        }

      refresh_lcd ();

// $[Generated Run-time code]
// [Generated Run-time code]$

    }
}

